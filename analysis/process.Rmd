---
title: "Check that we have data"
output:
  html_document:
    toc: true
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = F, message = F)
knitr::opts_chunk$set(dev = "png", dev.args = list(type = "cairo-png"))
options(knitr.table.format = "html")
knitr::opts_chunk$set(echo = F)
library(tidyverse)
library(viridis)
library(here)
library(ggthemes)
library(knitr)
library(jsonlite)

theme_set(theme_bw())

trials_loc <- "data/mme_pre_election-trials.csv"
workerids_loc <- "data/mme_pre_election-workerids.csv"

ParseJSONColumn <- function(x) {
  str_replace_all(x, c(
    "'" = '"',
    'I"d' = "I'd",
    '([A-Za-z]+)n"t' = "\\1n't",
    '([A-Za-z]+)"s' = "\\1's",
    'States" ' = "States' ",
    ": None" = ': "NA"' # don't replace "None" when it's a string 
  )) |> fromJSON(flatten = TRUE)
}

prolific_demog_loc <- "data/prolific_export_672046da44b2b4ceb69f3c97.csv"
```

## Read in data

```{r}
raw <- read_csv(here(trials_loc)) |>
  select(-proliferate.condition) |> 
  filter(!is.na(condition))

expectations_all <- raw |>
  filter(trial_type == "survey-slider") |> 
  select(workerid, condition, response) |> 
  mutate(response = map(response, ParseJSONColumn)) |> 
  unnest_longer(response, indices_to = "topic") |>
  mutate(response = as.numeric(response)) |>
  mutate(.by=workerid, probability=response/sum(as.numeric(response)))

cloze_all <- raw |> 
  filter(trial_type=="cloze") |> 
  select(workerid, item, response) |> 
  mutate(response=map(response, ParseJSONColumn)) |> 
  unnest(response)

spr_all <- raw |> filter(trial_type=="spr") |> 
  select(workerid, item, type, rt, sentence) |> 
  mutate(word=str_split(sentence, " "), rt=map(rt, ParseJSONColumn)) |> 
  rowwise() |> mutate(rt=list(rt[- 1])) |> ungroup() |> 
  unnest(c(word, rt)) |> 
  mutate(.by=c(workerid, item, sentence), word_number=row_number()) 
  
maze_all <- raw |> filter(trial_type=="maze") |> 
  select(workerid, item, type, rt, correct, sentence, word=words, distractor=distractors) |> 
  mutate(rt=map(rt, ParseJSONColumn),
         correct=map(correct, ParseJSONColumn), 
         word=map(word, ParseJSONColumn), 
         distractor=map(distractor, ParseJSONColumn)) |> 
  unnest(c(rt, correct, word, distractor)) |>
  mutate(correct=case_when(correct==0~FALSE,correct==1L~TRUE,.default=NA)) |>
  mutate(.by=c(workerid, item, sentence), word_number=row_number())

comp_question_all <- raw |> filter(trial_type=="html-button-response" & !is.na(item)) |> 
  select(workerid, item, response, stimulus) |> 
  mutate(response=case_when(response=="0"~"Yes",response=="1"~"No",.default=response))
# note that 0 means the first item in the list which was Yes 
#(annoyingly unintuitive, but whatevs)

recall_question_all <- raw |> filter(trial_type=="html-button-response" & !is.na(recall_order)) |> 
  select(workerid, response, stimulus, recall_order) |> 
  mutate(recall_order=map(recall_order, ParseJSONColumn)) |> 
  rowwise() |> 
  mutate(response=recall_order[as.numeric(response)+1]) |> 
  select(-recall_order)
```

Combine demographic info from Prolific and collected via survey
```{r}
workerids <- read_csv(here(workerids_loc)) |> 
  rename(prolific_id=prolific_participant_id)

prolific_demog_raw <- read_csv(here(prolific_demog_loc)) |>
  rename(prolific_id=`Participant id`)

demographics <- raw |>
  filter(trial_type=="survey") |> 
  select(workerid, condition, response) |> 
  mutate(response=map(response, ParseJSONColumn)) |> 
  unnest_longer(response, indices_to = "topic") |> 
  mutate(response=ifelse(response=="NA", NA, response)) |>
  # Ad hoc fixes:
  # 1. fix an apparent typo
  mutate(topic=ifelse(topic=="poltical_aff", "political_aff",topic)) |>
  # 2. Fix an error here. Political affil. was labeled in topic='news' for some particips
  #    Coalesce into "political_aff" if the answer was from that choice list
  mutate(topic = ifelse(
      topic == "news" & !(response %in% c("Daily", "Weekly", "Monthly", "Less than monthly", "Never")),
      "TEMP", 
      topic
  ))|>
  pivot_wider(names_from="topic",values_from="response") |>
  mutate(political_aff = coalesce(political_aff, TEMP)) |> select(-TEMP)

### CHECK
# look for any workerids that have multiple associated responses
workerids_many_trials <- demographics |> group_by(workerid) |> filter(n() > 1) |> 
  pull(workerid) |> unique()
if(length(workerids_many_trials)>1) warning("Some proliferate workerids are associated with multiple trials/demographic survey results. Will exclude them.")
# look for any prolific_ids that have multiple associated workerids
prolificids_many_workerids <- workerids |> group_by(prolific_id) |> filter(n() > 1) |>
  pull(prolific_id) |> unique()
if(length(prolificids_many_workerids)>1) warning("Some prolific_ids are associated with multiple proliferate workerids. Will exclude them.")

# Remove any participants who somehow had multiple runs, or multiple prolific_ids
demographics_and_prolific_uniq <- demographics |> 
  filter(!(workerid %in% workerids_many_trials)) |>
  left_join(workerids, join_by(workerid)) |>
  filter(!(prolific_id %in% prolificids_many_workerids)) |>
  left_join(prolific_demog_raw, join_by(prolific_id))

include <- demographics_and_prolific_uniq |> 
  filter(!(prolific_id %in% c("5dd32014b51b3e33ec0d07cc"))) |>
  filter(residence=="Yes", citizen=="Yes", english=="Yes") |>
  select(workerid,prolific_id) |> distinct()
```

```{r}
# We can use the demographics from the survey where they don't agree with demographics from prolific.  But just to check how much they disagree:
compare_demographics <- function(Col1,Col2,data=demographics_and_prolific_uniq) {
  not_matched <- filter(data, {{Col1}}!={{Col2}})
  pct_matched <- nrow(not_matched)/nrow(data)*100
  if ( nrow(not_matched) > 0) {
    message(sprintf("%.2f%% of values don't match.", pct_matched))
    print(data |> count({{Col1}}=={{Col2}}))
  }
  else message("Fully matched.")
  not_matched |> select(workerid,prolific_id,{{Col1}},{{Col2}})
}
# Some places where demographics reported in survey in experiment don't match those from prolific
compare_demographics(political_aff, `U.s. political affiliation`)
compare_demographics(age,Age)
compare_demographics(gender,Sex)
```

# Exclusion

```{r}
exclude_participants <- function(df) filter(df, workerid %in% include$workerid)

# Expectations
expectations <- exclude_participants(expectations_all)
# Cloze
cloze <- exclude_participants(cloze_all) |>
  mutate(
    type = sapply(
      tolower(trimws(response)), 
      \(s){ case_when(
        str_starts(s, "she/he |he/she |the pres|the next pres|the next us pres|the new pres|the newly elected|the newly appointed|the 46|the 47") ~
          "hedged",
        str_starts(s, "(?:she|her|hers)\\b") ~ 
          "pronoun female",
        str_starts(s, "(?:he|his|him)\\b") ~ 
          "pronoun male",
        str_starts(s, "(?:they|their|them)\\b") ~ 
          "pronoun neutral",
        str_starts(s, "trump|donald|president trump|president don") ~ 
          "Trump",
        str_starts(s, "harris|kamala|president harris|president kamala|the vice pres|the first black|vice pres|vice-pres") ~ 
          "Harris",
        .default = "OTHER"
      )})      
  )

# SPR
spr <- exclude_participants(spr_all)
spr <- spr |> mutate(included_rt = rt > 180 & rt < 5000)
spr_proportion_rt_excluded <- spr |> filter(!included_rt) |> nrow() / nrow(spr)

spr_with_next <- spr |> # include rts for next three words
  mutate(
    .by=c(workerid, item, sentence), 
    across(c(rt,included_rt),
    list("1next"=~lead(.x, 1L), "2next"=~lead(.x, 2L), "3next"=~lead(.x, 3L)))) |>
  filter(if_all(starts_with("included_rt")))


# Maze
maze <- exclude_participants(maze_all)

# Comp questions
comp_question <- exclude_participants(comp_question_all)

# Recall questions
recall_question <- exclude_participants(recall_question_all)
```

TODO: exclusion by comrehension questions.

# Preliminary plotting

## Expectations
```{r}
expectations |>
  ggplot(aes(response,topic)) + 
  labs(y='candidate',title="responded probability of being next president") +
  geom_violin(draw_quantiles=c(.5))

expectations |> 
  ggplot(aes(probability,topic)) +
  labs(y='candidate',title="normalized probability of being next president") +
  geom_violin(draw_quantiles=c(.5))
```

## Cloze

```{r}
cloze |> #filter(type!="OTHER") |>
  mutate(category=case_when(
    type %in% c("Harris", "pronoun female") ~ "female",
    type %in% c("Trump", "pronoun male") ~ "male",
    type %in% c("hedged", "pronoun neutral") ~ "neutral",
    .default = "OTHER"
  )) |>
  ggplot(aes(category, fill=type)) + 
  geom_bar() +
  labs(title="Cloze responses")
```

## Maze
```{r}

# Quick and dirty, get the pronouns for maze or spr target words

is_pronoun <- function(word) {
  pronouns <- c("she", "her", "hers", "he", "him", "his", "they", "them", "their", "theirs")
  clean_word <- gsub("^[[:punct:]]+|[[:punct:]]+$", "", word)
  tolower(clean_word) %in% pronouns
}
get_pronoun_gender <- function(word) {
  if (length(word) > 1) return(sapply(word, get_pronoun_gender))
  
  clean_word <- tolower(gsub("^[[:punct:]]+|[[:punct:]]+$", "", word))
  if (clean_word %in% c("she", "her", "hers")) return("female")
  else if (clean_word %in% c("he", "him", "his") ) return("male") 
  else if (clean_word %in% c("they", "them", "their", "theirs")) return("neutral")
  else return(NA)
}

maze |> filter(is_pronoun(word)) |>
  mutate(.by=c(workerid, item, sentence), 
    # This is not correct (some pronouns may not refer to president), but maybe would be useful as a preliminary peek
    nth_pronoun = row_number()) |>
  filter(correct) |>
  ggplot(aes(nth_pronoun, rt, color=factor(type))) +  facet_grid(~type) + 
  stat_summary()
```

```{r}
maze |> filter(correct, is_pronoun(word)) |> mutate(pronoun_gender = get_pronoun_gender(word)) |>
  ggplot(aes(pronoun_gender,rt, color=pronoun_gender)) + 
  stat_summary()

# Plot Maze RT on pronouns by gender against belief that president will be female
expectations |> 
  pivot_wider(names_from=topic,values_from=c(probability,response)) |> 
  select(workerid, starts_with("probability")) |> 
  # left_join(demographics_and_prolific_uniq) |> 
  left_join(maze) |> filter(correct, is_pronoun(word)) |> mutate(pronoun_gender = get_pronoun_gender(word)) |>
  ggplot(aes(probability_harris,rt,color=pronoun_gender)) + 
  geom_smooth(method="lm") +
  labs(x="belief that president will be Harris", y="Maze RT")
```

## SPR

```{r}
```